bands <- merge(upr, lwr)
head(bands)
head(upr)
head(lwr)
upr <- aggregate(sim.y ~ weight, FUN = function(x) quantile(x, probs = 0.95),
data = fit.lm2.simd2)
names(upr) <- c("weight","upr")
lwr <- aggregate(sim.y ~ weight, FUN = function(x) quantile(x, probs = 0.05),
data = fit.lm2.simd2)
names(lwr) <- c("weight","lwr")
bands <- merge(upr, lwr)
head(bands)
ggplot() +
geom_line(data = fit.lm2.simd,
aes(x = weight, y = sim.y, group = ii),
color = "gray", alpha = 0.5) +
geom_ribbon(data = bands, aes(x = weight, ymin = lwr, ymax = upr),
color = "purple") +
geom_abline(intercept = coef(fit.lm2)[1], slope = coef(fit.lm2)[2],
color = "blue") +
geom_point(data = d2, aes(x = weight, y = height))
ggplot() +
geom_line(data = fit.lm2.simd,
aes(x = weight, y = sim.y, group = ii),
color = "gray", alpha = 0.5) +
geom_ribbon(data = bands, aes(x = weight, ymin = lwr, ymax = upr),
fill = "purple", alpha = 0.3) +
geom_abline(intercept = coef(fit.lm2)[1], slope = coef(fit.lm2)[2],
color = "blue") +
geom_point(data = d2, aes(x = weight, y = height))
ggplot() +
geom_line(data = fit.lm2.simd,
aes(x = weight, y = sim.y, group = ii),
color = "red", alpha = 0.5) +
geom_ribbon(data = bands, aes(x = weight, ymin = lwr, ymax = upr),
fill = "purple", alpha = 0.3) +
geom_abline(intercept = coef(fit.lm2)[1], slope = coef(fit.lm2)[2],
color = "blue") +
geom_point(data = d2, aes(x = weight, y = height))
ggplot() +
geom_line(data = fit.lm2.simd,
aes(x = weight, y = sim.y, group = ii),
color = "red", alpha = 0.5) +
geom_ribbon(data = bands, aes(x = weight, ymin = lwr, ymax = upr),
fill = "purple", alpha = 0.3) +
geom_abline(intercept = coef(fit.lm2)[1], slope = coef(fit.lm2)[2],
color = "blue") +
geom_point(data = d2, aes(x = weight, y = height)) +
xlab("Weight (kg)") + ylab("Height (cm)") +
ggtitle("Height vs. weight, fitted, mean bands and prediction bands")
ggplot() +
geom_line(data = fit.lm2.simd,
aes(x = weight, y = sim.y, group = ii),
color = "red", alpha = 0.5) +
geom_ribbon(data = bands, aes(x = weight, ymin = lwr, ymax = upr),
fill = "purple", alpha = 0.3) +
geom_abline(intercept = coef(fit.lm2)[1], slope = coef(fit.lm2)[2],
color = "blue") +
geom_point(data = d2, aes(x = weight, y = height)) +
xlab("Weight (kg)") + ylab("Height (cm)") +
ggtitle("Height vs. weight, fitted (blue), mean band (red) \n and prediction band (purple)")
data("cherry_blossoms")
head(cherry_blossoms)
ch <- na.omit(cherry_blossoms)
head(ch)
dim(ch)
head(ch)
plot(doy ~ year , data = ch)
fit <- nls(doy ~ SStrlin(year, a, b, xs1, c, xs2, d), data = ch)
library(minpack.lm)
fit <- nlsLM(doy ~ SStrlin(year, a, b, xs1, c, xs2, d), data = ch)
ggplot(data = ch, aes(x = year, y = doy)) + geom_point() + geom_line(aes(y = fitted(fit)))
library(mgcv)
fitg <- gam(doy ~ s(year), data = ch)
ggplot(data = ch, aes(x = year, y = doy)) + geom_point() + geom_line(aes(y = fitted(fitg)))
?s
fitg <- gam(doy ~ s(year, k = 50), data = ch)
ggplot(data = ch, aes(x = year, y = doy)) + geom_point() + geom_line(aes(y = fitted(fitg)))
fitg <- gam(doy ~ s(year, k = 100), data = ch)
ggplot(data = ch, aes(x = year, y = doy)) + geom_point() + geom_line(aes(y = fitted(fitg)))
ggplot(data = ch, aes(x = year, y = doy)) + geom_point() + geom_line(aes(y = fitted(fit)))
fit
install.packages("apsimx")
library(apsimx)
?get_power_apsim_met
pwr <- get_power_apsim_met(lonlat = c(-93,42), dates = c("2012-01-01","2012-12-31"))
## Note that missing data is coded as -99
summary(pwr)
install.packages("nasapower")
pwr <- get_power_apsim_met(lonlat = c(-93,42), dates = c("2012-01-01","2012-12-31"))
## Note that missing data is coded as -99
summary(pwr)
check_apsim_met(pwr)
pwr$radn <- ifelse(pwr$radn == -99, NA, pwr$radn)
pwr.imptd <- impute_apsim_met(pwr, verbose = TRUE)
summary(pwr.imptd)
?impute_apsim_met
help(package = "apsimx")
extd.dir <- system.file("extdata", package = "apsimx")
inspect_apsimx("Maize.apsimx", src.dir = extd.dir, node = "Weather")
install.packages("MuMIn")
library(MuMIn)
help(package = "MulMn")
?MuMIn
?r.squaredGLMM
data(Orthodont, package = "nlme")
fm1 <- lme(distance ~ Sex * age, ~ 1 | Subject, data = Orthodont)
fmnull <- lme(distance ~ 1, ~ 1 | Subject, data = Orthodont)
r.squaredGLMM(fm1)
library(nlme)
data(Orthodont, package = "nlme")
fm1 <- lme(distance ~ Sex * age, ~ 1 | Subject, data = Orthodont)
fmnull <- lme(distance ~ 1, ~ 1 | Subject, data = Orthodont)
r.squaredGLMM(fm1)
r.squaredGLMM(fm1, fmnull)
fmm1 <- lmer(distance ~ Sex * age + (1 | Subject), data = Orthodont)
library(lme4)
fmm1 <- lmer(distance ~ Sex * age + (1 | Subject), data = Orthodont)
r.squaredGLMM(fmm1)
fm1
fmm1
library(rethinking)
var2
var(1:10)
var2(1:10)
var2(1:100)
var(1:100)
summary(fmm1)
anova(fmm1)
anova(fm1)
?pvalues
summary(fmm1)
car::Anova(fmm1)
lmerTest::anova(fmm1)
lmerTest:::anova(fmm1)
library(lmerTest)
?anova
help(package = "lmerTest")
anova(fmm1)
fmm1 <- lmerTest::lmer(distance ~ Sex * age + (1 | Subject), data = Orthodont)
anova(fmm1)
anova(fmm1, type = "I")
clgs <- cranlogs::cran_downloads("apsimx", from = "2020-07-01")
clgs
sum(clgs$count)
clgs <- cranlogs::cran_downloads("nlraa", from = "2020-01-13")
sum(clgs$count)
tail(clgs$count)
## Regresion bands
library(nlme)
library(nlraa)
library(ggplot2)
help(package = "nlraa")
install.packages("nlraa")
## Regresion bands
library(nlme)
library(ggplot2)
set.seed(12345)
x <- 1:30
y <- rnorm(30, x * 10, x * 2)
qplot(x, y)
dat <- data.frame(x = x, y = y)
## varPower is not really the model that generated the data
fm0 <- lm(y ~ x, data = dat)
fm1 <- gls(y ~ x, data = dat, weights = varPower())
## The model with the increasing variance is better
anova(fm1, fm0)
## The fitted models are the same but the uncertainty is very
## different
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(y = fitted(fm0)), color = "blue") +
geom_line(aes(y = fitted(fm1)), color = "purple")
## El método bootsrap es una de las pocas maneras de obtener
## bandas de incertidumbre dentro del marco de modelos mixtos
## (no Bayesianos). Esta función en el paquete nlraa simplifica
## el proceso
fm1.bt <- boot_lme(fm1, fitted, cores = 4)
library(nlraa)
## El método bootsrap es una de las pocas maneras de obtener
## bandas de incertidumbre dentro del marco de modelos mixtos
## (no Bayesianos). Esta función en el paquete nlraa simplifica
## el proceso
fm1.bt <- boot_lme(fm1, fitted, cores = 4)
dat$fm1.q5 <- apply(t(fm1.bt$t), 1, quantile, probs = 0.025)
dat$fm1.q95 <- apply(t(fm1.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.q5, ymax = fm1.q95),
fill = "gray", alpha = 0.7) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
fm0.prd <- predict(fm0, interval = "confidence")
dat2 <- cbind(dat, fm0.prd)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm0)), color = "blue") +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "gray", alpha = 0.7) +
geom_point() +
theme_bw() +
ggtitle("Modelo sin heterocedasticidad")
## En este último caso está claro que las bandas de incertibumbre
## En este último caso está claro que las bandas de incertibumbre
## son muy anchas para valores bajos de x e y y muy angostas para
fm0.bt <- boot_lm(fm0)
fm0.bt
confint(fm0)
library(car)
confint(fm0.bt)
?boot_lm
fm0.bt <- boot_lm(fm0, fitted, resid.type = "wild")
dat3 <- dat
dat3$fm0.q5 <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat3$fm0.q95 <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat3, aes( x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.q5, ymax = fm0.q95))
ggplot(data = dat3, aes( x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.q5, ymax = fm0.q95),
alpha = 0.6)
ggplot(data = dat3, aes( x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.lwr, ymax = fm0.upr),
color = "gray", alpha = 0.6)
## Usando la funcion boot_lm
fm0.bt <- boot_lm(fm0, fitted, resid.type = "wild")
dat3 <- dat
dat3$fm0.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat3$fm0.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat3, aes( x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.lwr, ymax = fm0.upr),
color = "gray", alpha = 0.6)
## Regresion bands
library(nlme)
library(nlraa)
library(ggplot2)
set.seed(12345)
x <- 1:30
y <- rnorm(30, x * 10, x * 2)
qplot(x, y)
dat <- data.frame(x = x, y = y)
## varPower is not really the model that generated the data
fm0 <- lm(y ~ x, data = dat)
fm1 <- gls(y ~ x, data = dat, weights = varPower())
## The model with the increasing variance is better
anova(fm1, fm0)
## The fitted models are the same but the uncertainty is very
## different
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(y = fitted(fm0)), color = "blue") +
geom_line(aes(y = fitted(fm1)), color = "purple")
## El método bootsrap es una de las pocas maneras de obtener
## bandas de incertidumbre dentro del marco de modelos mixtos
## (no Bayesianos). Esta función en el paquete nlraa simplifica
## el proceso
fm1.bt <- boot_lme(fm1, fitted, cores = 4)
dat$fm1.lwr <- apply(t(fm1.bt$t), 1, quantile, probs = 0.025)
dat$fm1.upr <- apply(t(fm1.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.lwr, ymax = fm1.upr),
fill = "gray", alpha = 0.7) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
fm0.prd <- predict(fm0, interval = "confidence")
dat2 <- cbind(dat, fm0.prd)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm0)), color = "blue") +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "gray", alpha = 0.7) +
geom_point() +
theme_bw() +
ggtitle("Modelo sin heterocedasticidad")
## Usando la funcion boot_lm
fm0.bt <- boot_lm(fm0, fitted, resid.type = "wild")
dat2$fm0.bt.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat2$fm0.bt.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
color = "blue", alpha = 0.5) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
color = "red", alpha = 0.5)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.5) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.5)
## Usando la funcion boot_lm
fm0.bt <- boot_lm(fm0, fitted, resid.type = "resample")
dat2$fm0.bt.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat2$fm0.bt.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.5) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.5)
## Usando la funcion boot_lm
fm0.bt <- boot_lm(fm0, fitted, R = 2e3, resid.type = "wild")
dat2$fm0.bt.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat2$fm0.bt.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.5) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.5)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.4) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.4)
fm0.bt <- boot_lm(fm0, fitted, R = 2e3, resid.type = "resample")
dat2$fm0.bt.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat2$fm0.bt.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.4) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.4)
## Usando la funcion boot_lm
fm0.bt <- boot_lm(fm0, fitted, R = 2e3, resid.type = "wild")
dat2$fm0.bt.lwr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.025)
dat2$fm0.bt.upr <- apply(t(fm0.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat2, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(x = x, y = fitted(fm0))) +
geom_ribbon(aes(ymin = fm0.bt.lwr, ymax = fm0.bt.upr),
fill = "blue", alpha = 0.4) +
geom_ribbon(aes(ymin = lwr, ymax = upr),
fill = "red", alpha = 0.4)
?varFixed
## What about a competing model?
fm2 <- gls(y ~ x, data = dat, weights = varFixed(~x))
fm2
var_cov(fm2)
fm2.bt <- boot_lme(fm2, fitted, cores = 4)
dat$fm2.lwr <- apply(t(fm2.bt$t), 1, quantile, probs = 0.025)
dat$fm2.upr <- apply(t(fm2.bt$t), 1, quantile, probs = 0.975)
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm2)), color = "blue") +
geom_ribbon(aes(ymin = fm2.lwr, ymax = fm2.upr),
fill = "gray", alpha = 0.7) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.lwr, ymax = fm1.upr),
fill = "gray", alpha = 0.7) +
geom_ribbon(aes(ymin = fm2.lwr, ymax = fm2.upr),
fill = "purple", alpha = 0.6) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.lwr, ymax = fm1.upr),
fill = "blue", alpha = 0.7) +
geom_ribbon(aes(ymin = fm2.lwr, ymax = fm2.upr),
fill = "red", alpha = 0.6) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.lwr, ymax = fm1.upr),
fill = "blue", alpha = 0.3) +
geom_ribbon(aes(ymin = fm2.lwr, ymax = fm2.upr),
fill = "red", alpha = 0.3) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad")
ggplot(data = dat, aes(x = x, y = y)) +
geom_line(aes(y = fitted(fm1)), color = "blue") +
geom_ribbon(aes(ymin = fm1.lwr, ymax = fm1.upr),
fill = "blue", alpha = 0.3) +
geom_ribbon(aes(ymin = fm2.lwr, ymax = fm2.upr),
fill = "red", alpha = 0.3) +
geom_point() +
theme_bw() +
ggtitle("Modelo con heterocedasticidad (fm1 vs. fm2)")
?varPower
vc2 <- var_cov(fm2)
image(log(vc[, ncol(vc):1]))
image(log(vc2[, ncol(vc2):1]))
image(log(vc2))
image(log(vc2[, ncol(vc2):1]))
image(log(vc1[, ncol(vc1):1]))
## fm1
vc1 <- var_cov(fm1)
image(log(vc1[, ncol(vc1):1]))
## fm1
vc1 <- var_cov(fm1)
image(log(vc1[, ncol(vc1):1]))
## fm2
vc2 <- var_cov(fm2)
image(log(vc2[, ncol(vc2):1]))
image(log(vc1[, ncol(vc1):1]))
## fm2
vc2 <- var_cov(fm2)
image(log(vc2[, ncol(vc2):1]))
vc1[1:10,1:10]
vc2[1:10,1:10]
matplot(cbind(diag(fm1), diag(fm2)))
class(diag(fm1))
matplot(cbind(diag(vc1), diag(vc2)))
anova(fm1, fm2)
matplot(cbind(diag(vc1), diag(vc2), x*2^2))
matplot(cbind(diag(vc1), diag(vc2), (x*2)^2))
matplot(cbind(diag(vc1), diag(vc2), (x*2)^2), main = "1 = fm1, 2 = fm2, 3 = sim")
matplot(cbind(diag(vc1), diag(vc2), (x*2)^2),
main = "1 = fm1, 2 = fm2, 3 = sim",
ylab = "variance", xlab = "x")
?varClasses
# fm1 seems to be a better model
anova(fm1, fm2, test = FALSE)
fml <- lm(log(y) ~ x, data = dat)
plot(fml)
qplot(x, log(y))
fml <- lm(log(y) ~ x + I(x^2), data = dat)
## Taking the log
dat$log.y <- log(dat$y)
fml <- lm(log.y ~ x + I(x^2), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fml)))
## nonlinear?
fmnl <- nls(log.y ~ SSasymp(x, Asym, R0, lrc), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl)))
fmnl2 <- nls(log.y ~ SStrlin(x, a, b, xs1, c, xs2, d), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl2)))
apropos("^SS")
?SSweibull
## weibull
fmnl3 <- nls(log.y ~ SSweibull(x, asym, drop, lrc, pwr), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl3)))
## ratio
fmnl4 <- nls(log.y ~ SSratio(x, a, b, c, d), data = dat)
## ratio
fmnl4 <- minpack.lm::nlsLM(log.y ~ SSratio(x, a, b, c, d), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl4)))
fmnl4
## ratio
getInitial(log.y ~ SSratio(x, a, b, c, d), data = dat)
apropos("^SS")
## expf
fmnl5 <- nls(log.y ~ SSexpf(x, a, c), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl5)))
## expf
fmnl5 <- nls(log.y ~ SSmicmen(x, a, c), data = dat)
ggplot(data = dat, aes(x = x, y = log.y)) +
geom_point() +
geom_line(aes(y = fitted(fmnl5)))
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_smooth()
## This is just to show that geom_smooth is not
## smart enough
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_smooth() +
geom_smooth(method = "lm", color = "red")
## This is just to show that geom_smooth is not
## smart enough
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_smooth() +
geom_smooth(method = "lm", color = "red", fill = "blue")
## This is just to show that geom_smooth is not
## smart enough
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_smooth() +
geom_smooth(method = "lm", color = "red", fill = "blue") +
geom_smooth(method = "gam", color = "purple")
## This is just to show that geom_smooth is not
## smart enough
ggplot(data = dat, aes(x = x, y = y)) +
geom_point() +
geom_smooth() +
geom_smooth(method = "lm", color = "red", fill = "blue") +
geom_smooth(method = "gam", fill = "purple")
