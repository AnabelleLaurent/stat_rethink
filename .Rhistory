sigma.vec[i] <- sigma.old
}
return(list(theta = theta.vec, sigma = sigma.vec, R = R.vec))
}
mm <- metrop(y, n = 1e3, start = c(10, 2))
plot(mm$R)
plot(mm$theta)
plot(mm$sigma)
summary(mm$R)
metrop <- function(x, n = 1e2, start = c(1, 1)){
theta.old <- start[1]
sigma.old <- start[2]
theta.vec <- numeric(n)
sigma.vec <- numeric(n)
R.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
sigma.new <- abs(sigma.old + rnorm(1))
f.0 <- -2 * sum(dnorm(x, mean = theta.old, sd = sigma.old, log = TRUE))
f.1 <- -2 * sum(dnorm(x, mean = theta.new, sd = sigma.new, log = TRUE))
R <- f.1 / f.0
R.vec[i] <- R
if(!is.finite(R)){
theta.vec[i] <- theta.old
sigma.vec[i] <- sigma.old
next
}
U <- runif(1)
if(R > U){
theta.old <- theta.new
sigma.old <- sigma.new
}
theta.vec[i] <- theta.old
sigma.vec[i] <- sigma.old
}
return(list(theta = theta.vec, sigma = sigma.vec, R = R.vec))
}
mm <- metrop(y, n = 1e3, start = c(10, 2))
plot(mm$theta)
plot(mm$sigma)
metrop <- function(x, n = 1e2, sigma = 1, start = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- -2 * sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- -2 * sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
R <- f.1 / f.0
if(!is.finite(R)){
theta.vec[i] <- theta.old
next
}
U <- runif(1)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 1e3, start = 10, sigma = sd(y))
mean(y)
plot(mm$theta)
sd(y)
dnorm(y, 14, 3, log = TRUE)
dnorm(y, 10, 3, log = TRUE)
-2 * sum(dnorm(y, 14, 3, log = TRUE))
-2 * sum(dnorm(y, 10, 3, log = TRUE))
sum(dnorm(y, 14, 3, log = TRUE))
sum(dnorm(y, 10, 3, log = TRUE))
metrop <- function(x, n = 1e2, sigma = 1, start = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
R <- f.1 / f.0
if(!is.finite(R)){
theta.vec[i] <- theta.old
next
}
U <- runif(1)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 1e3, start = 10, sigma = sd(y))
mean(y)
plot(mm$theta)
sum(dnorm(y, 14, 3, log = TRUE))
sum(dnorm(y, 15, 3, log = TRUE))
mean(y)
exp(-48)
exp(-49)
sum(exp(dnorm(y, 15, 3, log = TRUE)))
sum(exp(dnorm(y, 14, 3, log = TRUE)))
metrop <- function(x, n = 1e2, sigma = 1, start = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(exp(dnorm(x, mean = theta.old, sd = sigma, log = TRUE)))
f.1 <- sum(exp(dnorm(x, mean = theta.new, sd = sigma, log = TRUE)))
R <- f.1 / f.0
if(!is.finite(R)){
theta.vec[i] <- theta.old
next
}
U <- runif(1)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 1e3, start = 10, sigma = sd(y))
mean(mm$theta)
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
mm <- metrop(y, n = 50, start = 10, sigma = sd(y))
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
## Plotting the trace
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
mean(y)
mm2 <- metrop(y, n = 5e3, start = 7, sigma = sd(y))
## Computing the mean
mean(mm2$theta[500:5e3])
data(rugged)
d <- rugged
d$log_gdp <- log(d$rgdppc_2000)
dd <- d[ complete.cases(d$rgdppc_2000) , ]
dd$log_gdp_std <- dd$log_gdp / mean(dd$log_gdp)
dd$rugged_std <- dd$rugged / max(dd$rugged)
dd$cid <- ifelse( dd$cont_africa==1 , 1 , 2 )
## Using quadp
m8.3 <- quap(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dexp( 1 )
) , data=dd )
precis( m8.3 , depth=2 )
## R code 9.13
dat_slim <- list(
log_gdp_std = dd$log_gdp_std,
rugged_std = dd$rugged_std,
cid = as.integer( dd$cid )
)
str(dat_slim)
## R code 9.14
m9.1 <- ulam(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dexp( 1 )
) , data=dat_slim , chains=1 )
m9.1p <- ulam(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dunif( 0, 1 )
) , data=dat_slim , chains=1 )
library(rethinking)
data(rugged)
d <- rugged
d$log_gdp <- log(d$rgdppc_2000)
dd <- d[ complete.cases(d$rgdppc_2000) , ]
dd$log_gdp_std <- dd$log_gdp / mean(dd$log_gdp)
dd$rugged_std <- dd$rugged / max(dd$rugged)
dd$cid <- ifelse( dd$cont_africa==1 , 1 , 2 )
## Using quadp
m8.3 <- quap(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dexp( 1 )
) , data=dd )
precis( m8.3 , depth=2 )
## R code 9.13
dat_slim <- list(
log_gdp_std = dd$log_gdp_std,
rugged_std = dd$rugged_std,
cid = as.integer( dd$cid )
)
str(dat_slim)
## R code 9.14
m9.1 <- ulam(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dexp( 1 )
) , data=dat_slim , chains=1 )
m9.1p <- ulam(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dnorm( 0 , 0.3 ) ,
sigma ~ dunif( 0, 1 )
) , data=dat_slim , chains=1 )
m9.1
summary(m9.1)
?ulam
m9.1w <- ulam(
alist(
log_gdp_std ~ dnorm( mu , sigma ) ,
mu <- a[cid] + b[cid]*( rugged_std - 0.215 ) ,
a[cid] ~ dnorm( 1 , 0.1 ) ,
b[cid] ~ dexp( 0.3 ) ,
sigma ~ dexp( 1 )
) , data=dat_slim , chains=1 , iter = 1000, warmup = 700)
?student_t
?prior
library(brms)
?student
log(-1)
y
x
mean(y)
theta.old <- 14
theta.new <- 15
sigma <- sd(y)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.0
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
f.0
f.1
f.1 - f.0
f.1/f.0
-2 * f.0 / (-2 * f.1)
exp(f.1) / exp(f.0)
log(exp(f.1) / exp(f.0))
f.0 / f.1
metrop <- function(x, n = 1e2, start = list(theta = 1), sigma = 1){
theta.old <- start$theta
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
U <- runif(1)
R <- f.0 / f.1
## R = f.0 / f.1 is the same as log(f.0) - log(f.1) > log(U)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
metrop <- function(x, n = 1e2, start = 1, sigma = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
U <- runif(1)
R <- f.0 / f.1
## R = f.0 / f.1 is the same as log(f.0) - log(f.1) > log(U)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
plot(mm$theta)
f.0
f.1
f.1 / f.0
1 / (f.1 / f.0)
f.0/f.1
mm <- metrop(y, n = 1e3, start = 10, sigma = sd(y))
plot(mm$theta)
exp(-42)
exp(-45)
exp(-48) / exp(-49)
knitr::opts_chunk$set(echo = TRUE)
library(rethinking)
library(ggplot2)
library(tidyr)
library(brms)
f.0 <- sum(-2 * dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.0
f.1 <- sum(-2 * dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
f.1
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.0
exp(f.0)
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
exp(f.1)
exp(f.1)/exp(f.0)
f.1 - f.0
log(0.5)
metrop <- function(x, n = 1e2, start = 1, sigma = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
U <- runif(1)
R <- f.1 - f.0
## R = f.0 / f.1 is the same as log(f.0) - log(f.1) > log(U)
if(R > U){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
plot(mm$theta)
metrop <- function(x, n = 1e2, start = 1, sigma = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
U <- runif(1)
R <- f.1 - f.0
## R = f.0 / f.1 is the same as log(f.0) - log(f.1) > log(U)
if(R > log(U)){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
plot(mm$theta)
mm <- metrop(y, n = 1e3, start = 10, sigma = sd(y))
plot(mm$theta)
quantile(mm$theta, probs = c(0.025, 0.975))
confint(lm(y ~ 1))
metrop <- function(x, n = 1e2, start = 1, sigma = 1){
theta.old <- start
theta.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma, log = TRUE))
U <- runif(1)
## As stated above f.0 is the log-likelihood, thus exp(f.0) would be the
## likelihood. If I take the log of R then
## log(R) = log(exp(f.1)) - log(exp(f.0))
## This simplifies to f.1 - f.0
R <- f.1 - f.0
if(R > log(U)){
theta.old <- theta.new
}
theta.vec[i] <- theta.old
}
return(list(theta = theta.vec))
}
set.seed(1234)
y <- rnorm(20, 15, 3)
## The mean is easy
mean(y)
## Confidence interval
confint(lm(y ~ 1))
mm <- metrop(y, n = 100, start = 10, sigma = sd(y))
## Plotting the trace
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
## Getting the distribution
mm2 <- metrop(y, n = 5e3, start = 7, sigma = sd(y))
## Computing the mean
mean(mm2$theta[500:5e3])
quantile(mm2$theta[500:5e3], probs = c(0.025, 0.975))
ry <- rnorm(1e4, mean = mean(y), sd = sd(y)/sqrt(length(y)))
plot(density(mm2$theta[500:5e3]), main = "", xlab = "theta", col = "red")
lines(density(ry), col = "blue")
mtext("blue = normal")
mtext("blue = normal", col = "blue")
?mtext
mtext("blue = normal", col = "blue", at = c(0, 1))
mtext("blue = normal", col = "blue", at = c(11, 0.6))
mtext("blue = normal", col = "blue", at = c(12, 0.6))
mtext("blue = normal", col = "blue", at = c(12, 0.5))
ry <- rnorm(1e4, mean = mean(y), sd = sd(y)/sqrt(length(y)))
plot(density(mm2$theta[500:5e3]), main = "", xlab = "theta", col = "red")
lines(density(ry), col = "blue")
mtext("blue = normal", col = "blue", at = c(12, 1))
mtext("red = metropolis", col = "red", at = c(15, 1))
ry <- rnorm(1e4, mean = mean(y), sd = sd(y)/sqrt(length(y)))
plot(density(mm2$theta[500:5e3]), main = "", xlab = "theta", col = "red")
lines(density(ry), col = "blue")
mtext("blue = normal", col = "blue", at = c(12.5, 1))
mtext("red = metropolis", col = "red", at = c(15, 1))
metrop <- function(x, n = 1e2, start = list(theta = 1, sigma = 1)){
theta.old <- start$theta
sigma.old <- start$sigma
theta.vec <- numeric(n)
sigma.vec <- numeric(n)
for(i in 1:n){
theta.new <- theta.old + rnorm(1)
sigma.new <- sigma.old + rnorm(1)
if(sigma.new < 0) sigma.new <- sigma.old
f.0 <- sum(dnorm(x, mean = theta.old, sd = sigma.old, log = TRUE))
f.1 <- sum(dnorm(x, mean = theta.new, sd = sigma.new, log = TRUE))
U <- runif(1)
## As stated above f.0 is the log-likelihood, thus exp(f.0) would be the
## likelihood. If I take the log of R then
## log(R) = log(exp(f.1)) - log(exp(f.0))
## This simplifies to f.1 - f.0
R <- f.1 - f.0
if(R > log(U)){
theta.old <- theta.new
sigma.old <- sigma.new
}
theta.vec[i] <- theta.old
sigma.vec[i] <- sigma.old
}
return(list(theta = theta.vec, sigma = sigma.vec))
}
set.seed(12345)
y <- rnorm(25, 20, 5)
mm <- metrop(y)
plot(mm$theta)
plot(mm$sigma)
mm <- metrop(y, n = 1e4)
plot(mm$theta)
plot(mm$sigma)
set.seed(12345)
y <- rnorm(25, 20, 5)
mm <- metrop(y, n = 50)
## Plotting the trace
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
mm <- metrop(y, n = 75)
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
mm <- metrop(y, n = 100)
plot(mm$theta, xlab = "iteration", ylab = "theta", type = "l")
abline(h = mean(y), col = "red", lty = 2)
plot(mm$sigma, xlab = "iteration", ylab = "sigma", type = "l")
abline(h = mean(y), col = "red", lty = 2)
## Trace plot for sigma
plot(mm$sigma, xlab = "iteration", ylab = "sigma", type = "l")
abline(h = sd(y), col = "red", lty = 2)
mm2 <- metrop(y, n = 15e3)
hist(mm2$theta[1e3:15e3], xlab = "theta", main = "Metropolis theta",
freq = FALSE)
hist(mm2$sigma[1e3:15e3], xlab = "sigma", main = "Metropolis sigma",
freq = FALSE)
?hist
hist(mm2$theta[1e3:15e3], xlab = "theta", main = "Metropolis theta",
freq = FALSE, breaks = 20)
hist(mm2$theta[1e3:15e3], xlab = "theta", main = "Metropolis theta",
freq = FALSE, breaks = 30)
hist(mm2$sigma[1e3:15e3], xlab = "sigma", main = "Metropolis sigma",
freq = FALSE, breaks = 30)
hist(mm2$theta[1e3:15e3], xlab = "theta", main = "Metropolis theta",
freq = FALSE, breaks = 30)
abline(v = mean(y))
hist(mm2$theta[1e3:15e3], xlab = "theta", main = "Metropolis theta",
freq = FALSE, breaks = 30)
abline(v = mean(y), col = "red", lwd = 3)
hist(mm2$sigma[1e3:15e3], xlab = "sigma", main = "Metropolis sigma",
freq = FALSE, breaks = 30)
abline(v = sd(y), col = "red", lwd = 3)
sd(y)
quantile(mm2$sigma, probs = c(0.025, 0.975))
daty <- data.frame(y = y)
bb <- brm(y ~ 1, data = daty)
bb
flm <- lm(y ~ 1)
flm.bt <- boot_lm(flm, sigma, R = 1e4)
flm.bt <- boot_lm(flm, f = sigma, R = 1e4)
?sigma
?boot_lm
boot_lm
ff <- function(x) sigma(x)
flm.bt <- boot_lm(flm, f = ff, R = 1e4)
flm <- lm(y ~ 1, data = daty)
flm.bt <- boot_lm(flm, f = ff, R = 1e4)
library(car)
confint(flm.bt)
flm.bt <- boot_lm(flm, f = ff, R = 2e4)
confint(flm.bt)
confint(flm.bt, type = "perc")
quantile(flm.bt$t, probs = c(0.025, 0.975))
hist(flm.bt)
flm.bt
summary(flm.bt)
flm.bt <- boot_lm(flm, R = 2e4)
hist(flm.bt)
flm.bt
summary(flm.bt)
